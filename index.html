<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
        <title>Three</title>
        <meta name="description" content="A web-based version of the popular iOS game">
        <meta name="author" content="Tor Robinson">
        <link href="favicon.ico" rel="icon" type="image/x-icon">
        <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
        <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
        <script src="hammer.js"></script>
        
        <style>
               
            html, body, div, span, applet, object, iframe,
            h1, h2, h3, h4, h5, h6, p, blockquote, pre,
            a, abbr, acronym, address, big, cite, code,
            del, dfn, em, img, ins, kbd, q, s, samp,
            small, strike, strong, sub, sup, tt, var,
            b, u, i, center,
            dl, dt, dd, ol, ul, li,
            fieldset, form, label, legend,
            table, caption, tbody, tfoot, thead, tr, th, td,
            article, aside, canvas, details, embed, 
            figure, figcaption, footer, header, hgroup, 
            menu, nav, output, ruby, section, summary,
            time, mark, audio, video {
                margin: 0;
                padding: 0;
                border: 0;
                font-size: 100%;
                font: inherit;
                vertical-align: baseline;
            }
            /* HTML5 display-role reset for older browsers */
            article, aside, details, figcaption, figure, 
            footer, header, hgroup, menu, nav, section {
                display: block;
            }
            body {
                line-height: 1;
            }
            ol, ul {
                list-style: none;
            }
            blockquote, q {
                quotes: none;
            }
            blockquote:before, blockquote:after,
            q:before, q:after {
                content: '';
                content: none;
            }
            table {
                border-collapse: collapse;
                border-spacing: 0;
            }
            
            
            #container {
             /* Must manually set width/height */
             width:178px !important;
             height:178px !important;
             overflow:hidden !important;
            
             /* The magic centering code */
             margin:auto;
             position:absolute;
             top:0;bottom:0; /* Aligns Vertically - Remove for Horizontal Only */
             left:0;right:0; /* Aligns Horizontally - Remove for Vertical Only  */
            
             /* Prevent div from overflowing main window */
             max-width:100%;
             max-height:100%;
             overflow:auto;
                
                
            }
    
            html{
                font-family:monospace;
                line-height:30px;
                height:100%;
                width:100%;
                background-color:#EEE;
            }
            .empty{
                background-color:#AED6D2 !important;
                text-shadow:none !important;
                box-shadow:none !important;
                border-color:#7B9E9B !important;
            }
            .piece{
                border-radius: 2px 2px 4px 4px;
                margin:0px;
				width:30px !important;
                min-width:30px !important;
                display:inline-block;
                background-color:white;
                border-style:solid;
                border-width:1px;
                border-color:#999;
                height:30px !important;
                text-align:center;
                font-weight:bold;
                font-size:17px;
                
                -webkit-box-shadow: inset 0px -32px 0px -29px rgba(255,221,0,1);
                -moz-box-shadow: inset 0px -32px 0px -29px rgba(255,221,0,1);
                box-shadow: inset 0px -32px 0px -29px rgba(255,221,0,1);
                
                line-height:26px;
            }
            .piece.flipped{
                transform: translateX( -100% ) rotateY( -360deg );
            }
            .one{
                background-color:#69CDFF;
                color:white;
                border-style:solid;
                border-width:1px;
                border-color:rgba(72,106,122,0.4);
                
                -webkit-box-shadow: inset 0px -32px 0px -29px rgba(73,119,143,1);
                -moz-box-shadow: inset 0px -32px 0px -29px rgba(73,119,143,1);
                box-shadow: inset 0px -32px 0px -29px rgba(73,119,143,1);
            }
            .two{
                background-color:#FF6E6E;
                color:white;
                border-style:solid;
                border-width:1px;
                border-color:rgba(168,89,89,0.4);
                
                -webkit-box-shadow: inset 0px -32px 0px -29px rgba(153,64,64,1);
                -moz-box-shadow: inset 0px -32px 0px -29px rgba(153,64,64,1);
                box-shadow: inset 0px -32px 0px -29px rgba(153,64,64,1);
            }
            .redText{
                color:#FF6E6E;
            }
            .smallerText{
                font-size: 15px;
            }
            #output{
                width:150px;
                height:150px;
                display:inline-block;
                background-color: #C1E8E4;
                padding:3px;
                border-style:solid;
                border-width:1px;
                border-color:#7B9E9B;
                overflow:hidden;
                line-height:0px;
                -webkit-box-shadow: inset 0px 2px 13px 1px rgba(0,0,0,0.23);
                -moz-box-shadow: inset 0px 2px 13px 1px rgba(0,0,0,0.23); 
                box-shadow: inset 0px -32px 0px -29px #FF6E6E;
               
                border-radius: 10px;
            }
            
            .red{
                -webkit-box-shadow: inset 0px 2px 13px 1px #FF6E6E  !important;
                -moz-box-shadow: inset 0px 2px 13px 1px #FF6E6E !important; 
                box-shadow: inset 0px -32px 0px -29px #FF6E6E !important;
            }
            
            .blue{
                -webkit-box-shadow: inset 0px 2px 13px 1px #69CDFF !important;
                -moz-box-shadow: inset 0px 2px 13px 1px #69CDFF !important; 
                box-shadow: inset 0px -32px 0px -29px #69CDFF !important;
            }
            
            .white{
                -webkit-box-shadow: inset 0px 2px 13px 1px white !important;
                -moz-box-shadow: inset 0px 2px 13px 1px white !important; 
                box-shadow: inset 0px -32px 0px -29px white !important;
            }
            
            
            
            .flip-container {
                -webkit-perspective: 1000;
                -moz-perspective: 1000;
                -o-perspective: 1000;
                perspective: 1000;
                
                top:0;
            }

            .flip-container, .front, .back {
                width: 30px !important;
                height: 30px  !important;
                padding:0;
                display:inline-block;
                margin:3px;
            }
            
            .flipper {
                -moz-transform: perspective(1000px);
                -moz-transform-style: preserve-3d;
                width: 30px  !important;
                height: 30px  !important;
                display:inline-block;
                position: relative;
            }
            
            .front, .back {
                
                margin:3px;
                
                -webkit-backface-visibility: hidden;
                -moz-backface-visibility: hidden;
                -o-backface-visibility: hidden;
                backface-visibility: hidden;
            
                -webkit-transition: 0.6s;
                -webkit-transform-style: preserve-3d;
            
                -moz-transition: 0.6s;
                -moz-transform-style: preserve-3d;
            
                -o-transition: 0.6s;
                -o-transform-style: preserve-3d;
            
                -ms-transition: 0.6s;
                -ms-transform-style: preserve-3d;
            
                transition: 0.6s;
                transform-style: preserve-3d;
            
             
                
                position: absolute;
               
            }
            
            .back {
                -webkit-transform: rotateY(-180deg);
                -moz-transform: rotateY(-180deg);
                -o-transform: rotateY(-180deg);
                -ms-transform: rotateY(-180deg);
                transform: rotateY(-180deg);
            }
            
            .flip-container .back.flipped {
                -webkit-transform: rotateY(0deg);
                -moz-transform: rotateY(0deg);
                -o-transform: rotateY(0deg);
                -ms-transform: rotateY(0deg);
                transform: rotateY(0deg);
            }
            
            .flip-container .front.flipped {
                -webkit-transform: rotateY(180deg);
                -moz-transform: rotateY(180deg);
                -o-transform: rotateY(180deg);
                transform: rotateY(180deg);
            }
            
            
            .front {
                z-index: 2;
            }
			
			.connector{
				line-height:0px !important;
				height:0px;
				width:0px;
				margin:0px;
				background-color:black;
				display:inline-block;
				position:absolute;
			}
				.goRight{
					height:2px !important;
					width:10px !important;
					top: 19px;
					left: 29px;
				}
				
				.goLeft{
					height:2px !important;
					width:10px !important;
					top: 19px;
					left: 2px;
				}
				.goUp{
					height:10px !important;
					width:2px !important;
					top: 4px;
					left: 19px;
				}
				.goDown{
					height:10px !important;
					width:2px !important;
					top: 29px;
					left: 19px;
				}
               
        </style>
    
    <!--[if IE]>
        <style>
            #output{line-height:13px !important;}
             .piece{
                    margin:1px !important;
                }
                #container{
                    margin: 0 auto !Important;
                    margin-top: 30px !important;
                }
        </style>
    <![endif]-->
       
    </head>
    <body>
        <div id="container">
            <div id="output" style="display: inline-block; opacity: 1;" class="red"></div>
        </div>
        
        <script type="text/javascript">var isNotStupidIE = true;</script>
    <!--[if IE]>
    <script type="text/javascript">
       var isNotStupidIE = false;
    </script>
    <![endif]-->
     <script type="text/javascript">
			//HOW DOES I JAVASCRIPT?
            //first attempt at making a game with javascript... uh oh
            //Helpers///////////////////////////////////////////
            if (isNotStupidIE) {
                var pieceTemplate = "<div class='flip-container'><div class='flipper'> <div class='front [CLASS]'>[CONTENTS]</div><div class='[CLASS] back'></div></div><div class='connector goUp' style='display:[UPDISPLAY];'></div><div class='connector goDown' style='display:[DOWNDISPLAY];'></div><div class='connector goLeft' style='display:[LEFTDISPLAY];'></div><div class='connector goRight' style='display:[RIGHTDISPLAY];'></div></div>";
                var emptyTemplate = "<div class='flip-container'><div class='flipper'> <div class='front piece empty'></div><div class='piece empty back'></div></div></div>";
            } else {
                var pieceTemplate = "<span class='[CLASS]'>[CONTENTS]</span>";
                var emptyTemplate = "<span class='empty piece'>&nbsp;</span>";
            }
            
            alert("-Use the arrow keys (desktop) or swipe (mobile) to move every piece around the board.\n-Every time you move, a random piece is added.\n-The upcoming color of this piece is indicated by the strip at the bottom of the play area.\n-Push two numbers together to combine them.\n-1's can only be merged with 2's and vice versa\n-3's and higer can only be merged with duplicates\n-The game ends when the board is full and no further moves can be made.");
            
            
            function randomBetween(start, end) {
                return Math.floor(Math.random() * end) + start;
            }
            
            var highScore = 0;
            //draw the pieces
            function DrawBoard(board) {
                var outputText = "";
                for (var y = 0; y < board.pieces.length; y++) {
                    for (var x = 0; x < board.pieces.length; x++) {
                        if (board.pieces[y][x] == null)
                            outputText += emptyTemplate;
                        else {
                            var leftDisplay = "none";
                            var rightDisplay = "none";
                            var upDisplay = "none";
                            var downDisplay = "none";
            
                            if (board.pieces[y][x].canRight) rightDisplay = "inline-block";
                            if (board.pieces[y][x].canLeft) leftDisplay = "inline-block";
                            if (board.pieces[y][x].canUp) upDisplay = "inline-block";
                            if (board.pieces[y][x].canDown) downDisplay = "inline-block";
                            outputText += pieceTemplate.split("[CLASS]").join(board.pieces[y][x].style).split("[CONTENTS]").join(board.pieces[y][x].value).split("[RIGHTDISPLAY]").join(rightDisplay).split("[LEFTDISPLAY]").join(leftDisplay).split("[UPDISPLAY]").join(upDisplay).split("[DOWNDISPLAY]").join(downDisplay);
                        }
            
            
                    }
                    outputText += "<br/>";
                }
            
                document.getElementById("output").innerHTML = outputText;
            
                $('#output').removeClass("red");
                $('#output').removeClass("blue");
                $('#output').removeClass("white");
            
                if (board.nextNumber == 1)
                    $('#output').addClass("blue");
                if (board.nextNumber == 2)
                    $('#output').addClass("red");
                if (board.nextNumber > 2)
                    $('#output').addClass("white");
            
            
            
                setTimeout(function () {
                    $(".front.flipped,.back.flipped").removeClass("flipped");
                }, 2);
            }
            /////////////////////////////////////////////////////
            
            
            
            //The game board/////////////////////////////////////
            function Board() {
                this.pieces = [
                    [null, null, null, null],
                    [null, null, null, null],
                    [null, null, null, null],
                    [null, null, null, null]
                ];
                this.score = 0;
                this.isDone = false;
                this.nextNumber = randomBetween(1, 3);
            }
            
            Board.prototype.PrepareTurn = function () { //ensure there is a move to make and set score
                var score = 0;
                var highestPiece = 0;
                for (var y = 0; y < this.pieces.length; y++) {
                    for (var x = 0; x < this.pieces.length; x++) {
                        if (this.pieces[y][x] != null) {
                            if (this.pieces[y][x].value > highestPiece) highestPiece = this.pieces[y][x].value;
                            this.pieces[y][x].style = this.pieces[y][x].style.split("redText").join();
                            switch (this.pieces[y][x].value) {
                            case 1:
                                score += 0;
                                break;
                            case 2:
                                score += 0;
                                break;
                            case 3:
                                score += 3;
                                break;
                            case 6:
                                score += 9;
                                break;
                            case 12:
                                score += 27;
                                break;
                            case 24:
                                score += 81;
                                break;
                            case 48:
                                score += 243;
                                break;
                            case 96:
                                score += 729;
                                break;
                            case 192:
                                score += 2187;
                                break;
                            case 384:
                                score += 6561;
                                break;
                            case 768:
                                score += 19683;
                                break;
                            case 1536:
                                score += 59049;
                                break;
                            default:
                                score += 59049;
                                break;
                            }
                        }
                    }
                }
            
                //highlight highest pieces
                $('.piece').removeClass('redText');
                for (var y = 0; y < this.pieces.length; y++)
                    for (var x = 0; x < this.pieces.length; x++)
                        if (this.pieces[y][x] != null)
                            if (this.pieces[y][x].value == highestPiece && highestPiece > 3)
                                this.pieces[y][x].style += " redText";
            
                this.score = score;
                document.title = this.score;
                if (!this.HasPossibleMove()) {
                    this.isDone = true;
                    if (score > highScore) highScore = score;
                    DrawBoard(theBoard);
                    setTimeout(function () {
                        alert("No more moves possible.\n\nFinal score: " + score + ".\nSession's highscore: " + highScore + "\n\nPress OK to reset.");
                        $("#output").fadeOut();
                        setTimeout(function () {
                            theBoard = new Board();
                            theBoard.RandomFill();
                            theBoard.PrepareTurn();
                            DrawBoard(theBoard);
                            $("#output").fadeIn();
                        }, 500);
            
                    }, 500);
            
                }
            }
            
            Board.prototype.HasPossibleMove = function () {
                console.clear();
            
                //clear connectors booleans
                for (var y = 0; y < this.pieces.length; y++) {
                    for (var x = 0; x < this.pieces.length; x++) {
                        if (this.pieces[y][x] != null) {
                            this.pieces[y][x].canRight = false;
                            this.pieces[y][x].canLeft = false;
                            this.pieces[y][x].canUp = false;
                            this.pieces[y][x].canDown = false;
                        }
                    }
                }
            
                var hasmove = false;
                var directions = [
                    [-1, 0],
                    [1, 0],
                    [0, -1],
                    [0, 1]
                ];
                for (var y = 0; y != 4; y += 1) {
                    for (var x = 0; x != 4; x += 1) { //for each piece
            
                        for (var d = 0; d < 4; d++) { //for each direction
                            var merges = false;
                            if (this.pieces[y][x] != null) { //if there's a piece here
                                var xoffset = directions[d][0];
                                var yoffset = directions[d][1];
                                if ( //first if we aren't moving out of bounds
                                    (xoffset != 0 && (x + xoffset >= 0 && x + xoffset <= 3)) ||
                                    (yoffset != 0 && (y + yoffset >= 0 && y + yoffset <= 3))
                                ) {
                                    //Second will I not hit another piece?
                                    if (this.pieces[y + yoffset][x + xoffset] == null) {
                                        hasmove = true; //means there's a free space, so we're not done
                                        merges = false;
                                    } else {
            
                                        if (this.pieces[y][x].value + this.pieces[y + yoffset][x + xoffset].value == 3) {
                                            hasmove = true;
                                            merges = true;
                                        } else if (this.pieces[y][x].value == this.pieces[y + yoffset][x + xoffset].value && this.pieces[y][x].value != 1 && this.pieces[y][x].value != 2) {
                                            hasmove = true;
                                            merges = true;
                                        }
            
                                        if (hasmove && merges) { //piece being moved into can be merged into
                                            if (d == 0) { //left
                                                this.pieces[y][x].canLeft = true;
                                            } else if (d == 1) { //right
                                                this.pieces[y][x].canRight = true;
                                            } else if (d == 2) { //up
                                                this.pieces[y][x].canUp = true;
                                            } else if (d == 3) { //down
                                                this.pieces[y][x].canDown = true;
                                            }
                                        }
                                    }
                                } else {
                                    //we're pushing against a wall.
                                }
                            } else {
                                //no piece? that means a move is possible.
                                hasmove = true;
                            }
            
                        }
                    }
                }
                return hasmove;
            }
            
            Board.prototype.AddPiece = function (newPiece, x, y) {
                if (this.pieces[y][x] == null)
                    this.pieces[y][x] = newPiece;
                else
                    throw "A piece already exists at " + x + "," + y;
            }
            
            Board.prototype.GetPiecePositon = function (piece) {
                for (var y = 0; y < this.pieces.length; y++) {
                    for (var x = 0; x < this.pieces.length; x++) {
                        if (this.pieces[y][x] == piece)
                            return [x, y];
                    }
                }
                throw "Piece does not exist on board. Position unknown.";
            }
            
            Board.prototype.ChangePiecePosition = function (piece, newx, newy) {
                var oldPos = this.GetPiecePositon(piece);
                this.pieces[newy][newx] = piece;
                this.pieces[oldPos[1]][oldPos[0]] = null;
            
            }
            
            Board.prototype.MoveLeft = function () {
                this.Move(-1, 0);
            }
            Board.prototype.MoveRight = function () {
                this.Move(1, 0);
            }
            Board.prototype.MoveUp = function () {
                this.Move(0, -1);
            }
            Board.prototype.MoveDown = function () {
                this.Move(0, 1);
            }
            
            Board.prototype.Move = function (xoffset, yoffset) {
                var didMove = false;
            
                var start = 0;
                var end = 4;
                var step = +1;
                if (xoffset > 0 || yoffset > 0) { //if going down/right, resolve in reverse order
                    start = 3;
                    end = -1;
                    step = -1;
                }
                for (var y = start; y != end; y += step) {
                    for (var x = start; x != end; x += step) {
                        if (this.pieces[y][x] != null) { //if there's a piece here                    
                            this.pieces[y][x].style = this.pieces[y][x].style.replace("flipped", "");
                            if ( //if we aren't moving out of bounds
                                xoffset != 0 && (x + xoffset >= 0 && x + xoffset <= 3) ||
                                yoffset != 0 && (y + yoffset >= 0 && y + yoffset <= 3)
                            ) {
                                //Second will I not hit another piece?
                                if (this.pieces[y + yoffset][x + xoffset] == null) {
                                    //Move to empty space
                                    this.ChangePiecePosition(
                                        this.pieces[y][x],
                                        x + xoffset,
                                        y + yoffset);
                                    didMove = true;
                                } else {
                                    //hits another piece
                                    if (this.pieces[y][x].value + this.pieces[y + yoffset][x + xoffset].value == 3) {
                                        this.Combine(x, y, x + xoffset, y + yoffset, 3);
                                        didMove = true;
                                    } else if (this.pieces[y][x].value == this.pieces[y + yoffset][x + xoffset].value && this.pieces[y][x].value != 1 && this.pieces[y][x].value != 2) {
                                        this.Combine(x, y, x + xoffset, y + yoffset, this.pieces[y][x].value * 2);
                                        didMove = true;
                                    }
                                }
                            } else {
                                //we're against a wall.
                            }
                        }
                    }
                }
                if (didMove) this.AddRandom(xoffset, yoffset);
                //TODO: check for possible moves, if non, end.
            }
            
            Board.prototype.RandomFill = function () {
                //9 random pieces , 3 1s 3 2s 3 3s
            
                //Pick 9 random unique coordinates
                var spots = [];
                var randx;
                var randy;
                var values = [
                    1, 1, 1,
                    2, 2, 2,
                    3, 3, 3
                ];
            
            
                while (spots.length < 9) {
                    randx = randomBetween(0, 4);
                    randy = randomBetween(0, 4);
            
                    var found = false;
                    //check to see if it exists or not
                    for (var i = 0; i < spots.length; i++)
                        if (spots[i][0] == randx && spots[i][1] == randy)
                            found = true;
            
                    if (!found)
                        spots.push([
                            [randx],
                            [randy]
                        ]);
                }
            
                for (var i = 0; i < spots.length; i++) {
                    theBoard.AddPiece(new Piece(values[i], ""), spots[i][0], spots[i][1]);
                }
            
            
            
                //For each space, randomly pull from a 1,2, and 3 pool until empty
            
            
            }
            
            Board.prototype.Combine = function (fromx, fromy, tox, toy, newValue) {
                this.pieces[fromy][fromx] = null;
                this.pieces[toy][tox] = null;
                var extraStyle = "";
                if (newValue > 99) extraStyle += " smallerText";
                this.AddPiece(new Piece(newValue, "piece flipped" + extraStyle), tox, toy);
            }
            
            Board.prototype.GetRandomPieceValue = function () {
                //based on current board values, return an appropriate new value for a new piece
                var options = [];
                var total = 0;
                var count = 0;
                for (var y = 0; y < this.pieces.length; y++) {
                    for (var x = 0; x < this.pieces.length; x++) {
                        if (this.pieces[y][x] != null) {
                            total += this.pieces[y][x].value;
                            count++;
                        }
                    }
                }
                var average = total / count;
                if (average < 3)
                    options = [1, 1, 2, 2, 3, 3];
                if (average >= 3 && average < 6)
                    options = [1, 2, 3, 3];
                if (average >= 6 && average < 12)
                    options = [1, 1, 1, 2, 2, 2, 3, 3, 3, 6, 12];
                if (average >= 12)
                    options = [1, 1, 1, 2, 2, 2, 3, 3, 3, 6, 6, 6, 12, 24];
                var ret = options[randomBetween(0, options.length)];
                return ret;
            }
            
            
            Board.prototype.GetEmpties = function () {
                var empties = [];
                for (var y = 0; y < this.pieces.length; y++) {
                    for (var x = 0; x < this.pieces.length; x++) {
                        if (this.pieces[y][x] == null)
                            empties.push([
                                [x],
                                [y]
                            ]);
                    }
                }
                return empties;
            }
            
            Board.prototype.AddRandom = function (xoffset, yoffset) {
            
                //find all empty spaces
                var allEmpties = this.GetEmpties();
                var empties = [];
                for (var i = 0; i < allEmpties.length; i++) {
            
                    if (xoffset == -1 && yoffset == 0) { //left
                        if (allEmpties[i][0] == 3) //right column
                            empties.push(allEmpties[i]);
                    }
                    if (xoffset == 1 && yoffset == 0) { //right
                        if (allEmpties[i][0] == 0) //left column
                            empties.push(allEmpties[i]);
                    }
                    if (xoffset == 0 && yoffset == -1) { //up
                        if (allEmpties[i][1] == 3) //bottom row
                            empties.push(allEmpties[i]);
                    }
                    if (xoffset == 0 && yoffset == 1) { //down
                        if (allEmpties[i][1] == 0) //top row
                            empties.push(allEmpties[i]);
                    }
            
            
                }
                if (empties.length == 0) {
                    this.BoardFull();
                    return;
                } else {
                    //pick a random empty space and add a random new piece in its place
                    var piecePlace = empties[randomBetween(0, empties.length)];
                    theBoard.AddPiece(
                        new Piece(this.nextNumber, ""),
                        piecePlace[0],
                        piecePlace[1]
                    );
                    this.nextNumber = this.GetRandomPieceValue();
                }
            }
            /////////////////////////////////////////////////////
            
            
            
            
            //Pieces/////////////////////////////////
            function Piece(value, style) {
                this.value = value;
                if (style == "") {
                    this.style = "piece"
                    if (value == 1)
                        this.style = "one piece";
                    if (value == 2)
                        this.style = "two piece";
                    if (value > 99)
                        this.style = "smallerText piece"
                }
                if (style != "") {
                    this.style = style;
                }
                this.canRight = false;
                this.canLeft = false;
                this.canUp = false;
                this.canDown = false;
            }
            /////////////////////////////////////////
            
            
            //Set up game board
            var theBoard = new Board();
            theBoard.RandomFill();
            DrawBoard(theBoard);
            
            
            
            //Bind controls
            document.onkeydown = function (e) {
            
                e = e || event // //because IE8 sucks
            
                if (!theBoard.isDone) {
                    if (e.keyCode == 37)
                        theBoard.MoveLeft();
                    if (e.keyCode == 39)
                        theBoard.MoveRight();
                    if (e.keyCode == 38)
                        theBoard.MoveUp();
                    if (e.keyCode == 40)
                        theBoard.MoveDown();
                    theBoard.PrepareTurn();
                }
            
                DrawBoard(theBoard); //draw the first frame
            };
            
            //handle mobile swiping. Super glitchy for some reason. Iffy. Remove?
            var hammertime = Hammer(document, {
                drag_lock_to_axis: true
            }).on("drag dragup dragdown dragleft dragright swipe swipeup swipedown swipeleft swiperight", function (event) {
                event.gesture.preventDefault();
                if (event.type == "swipeup")
                    theBoard.MoveUp();
                if (event.type == "swipedown")
                    theBoard.MoveDown();
                if (event.type == "swipeleft")
                    theBoard.MoveLeft();
                if (event.type == "swiperight")
                    theBoard.MoveRight();
            
                theBoard.PrepareTurn();
                DrawBoard(theBoard);
            
            });
     </script>
    
    
</body></html>